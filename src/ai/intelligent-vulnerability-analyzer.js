// src/ai/intelligent-vulnerability-analyzer.js
// 智能化漏洞分析器 - 使用启发式算法和规则增强漏洞检测

class IntelligentVulnerabilityAnalyzer {
  constructor(options = {}) {
    this.options = {
      enableRiskScoring: true,
      enableVulnerabilityCorrelation: true,
      enablePatternLearning: false, // 启发式学习，非ML
      enableContextAnalysis: true,
      riskThreshold: options.riskThreshold || 0.7, // 风险阈值
      correlationThreshold: options.correlationThreshold || 0.5, // 关联阈值
      ...options
    };
    
    // 漏洞风险评分映射
    this.riskFactors = {
      'xss': { baseScore: 8.0, complexity: 0.7, exploitability: 0.9 },
      'sql-injection': { baseScore: 9.0, complexity: 0.5, exploitability: 0.8 },
      'csrf': { baseScore: 6.5, complexity: 0.6, exploitability: 0.7 },
      'ssrf': { baseScore: 8.6, complexity: 0.6, exploitability: 0.8 },
      'deserialization': { baseScore: 9.8, complexity: 0.4, exploitability: 0.9 },
      'file-inclusion': { baseScore: 7.5, complexity: 0.6, exploitability: 0.8 },
      'prototype-pollution': { baseScore: 7.0, complexity: 0.5, exploitability: 0.7 },
      'insecure-deserialization': { baseScore: 9.8, complexity: 0.4, exploitability: 0.9 }
    };
    
    // 漏洞关联规则
    this.correlationRules = [
      { 
        primary: 'xss', 
        secondary: 'input-validation', 
        strength: 0.8,
        description: 'XSS漏洞通常与输入验证不足相关'
      },
      { 
        primary: 'sql-injection', 
        secondary: 'parameterized-queries', 
        strength: 0.9,
        description: 'SQL注入漏洞通常与未使用参数化查询相关'
      },
      { 
        primary: 'csrf', 
        secondary: 'csrf-tokens', 
        strength: 0.9,
        description: 'CSRF漏洞通常与缺少CSRF令牌相关'
      }
    ];
    
    // 上下文分析规则
    this.contextRules = {
      'database-connection': ['sql-injection', 'sqli'],
      'user-input': ['xss', 'command-injection', 'file-inclusion'],
      'authentication': ['session-fixation', 'csrf', 'auth-bypass'],
      'file-upload': ['file-inclusion', 'malicious-file-upload', 'path-traversal'],
      'api-endpoint': ['rate-limiting', 'input-validation', 'authentication']
    };
    
    // 漏洞置信度评分
    this.confidenceFactors = {
      patternMatch: 0.7,
      contextMatch: 0.2,
      ruleConsistency: 0.1
    };
  }

  /**
   * 分析漏洞并提供智能评分
   * @param {Array} vulnerabilities - 漏洞数组
   * @param {Object} context - 上下文信息
   * @returns {Array} - 增强后的漏洞数组
   */
  analyzeVulnerabilities(vulnerabilities, context = {}) {
    if (!Array.isArray(vulnerabilities)) {
      return [];
    }
    
    const analyzedVulns = vulnerabilities.map(vuln => {
      const enhancedVuln = { ...vuln };
      
      // 计算风险评分
      if (this.options.enableRiskScoring) {
        enhancedVuln.riskScore = this.calculateRiskScore(vuln);
      }
      
      // 计算置信度
      enhancedVuln.confidence = this.calculateConfidence(vuln, context);
      
      // 分析上下文影响
      if (this.options.enableContextAnalysis) {
        enhancedVuln.contextImpact = this.analyzeContextImpact(vuln, context);
      }
      
      // 标记严重性级别
      enhancedVuln.severityLevel = this.determineSeverityLevel(enhancedVuln.riskScore || 0);
      
      return enhancedVuln;
    });
    
    // 执行漏洞关联分析
    if (this.options.enableVulnerabilityCorrelation) {
      const correlatedResults = this.analyzeCorrelations(analyzedVulns, context);
      return correlatedResults.vulnerabilities;
    }
    
    return analyzedVulns;
  }

  /**
   * 计算漏洞风险评分
   * @param {Object} vulnerability - 漏洞对象
   * @returns {number} - 风险评分 (0-1)
   */
  calculateRiskScore(vulnerability) {
    const ruleId = vulnerability.ruleId || 'unknown';
    const severity = vulnerability.severity || 'medium';
    const description = vulnerability.description || '';
    
    // 基础风险评分
    let baseScore = 0.5; // 默认中等风险
    
    // 查找特定漏洞类型的风险因子
    for (const [type, factors] of Object.entries(this.riskFactors)) {
      if (ruleId.toLowerCase().includes(type) || description.toLowerCase().includes(type)) {
        baseScore = factors.baseScore / 10; // 转换为0-1范围
        break;
      }
    }
    
    // 根据严重性调整评分
    switch (severity.toLowerCase()) {
      case 'critical':
        baseScore = Math.min(1.0, baseScore + 0.3);
        break;
      case 'high':
        baseScore = Math.min(1.0, baseScore + 0.2);
        break;
      case 'medium':
        baseScore = Math.min(1.0, baseScore + 0.1);
        break;
      case 'low':
        baseScore = Math.max(0, baseScore - 0.1);
        break;
    }
    
    // 考虑漏洞位置的影响
    const file = vulnerability.file || '';
    if (file.includes('auth') || file.includes('login') || file.includes('admin')) {
      baseScore = Math.min(1.0, baseScore + 0.1); // 认证相关文件风险更高
    }
    
    // 考虑漏洞的潜在影响
    if (description.toLowerCase().includes('remote') || description.toLowerCase().includes('execution')) {
      baseScore = Math.min(1.0, baseScore + 0.15); // 远程执行风险更高
    }
    
    return Math.max(0, Math.min(1.0, baseScore));
  }

  /**
   * 计算漏洞检测置信度
   * @param {Object} vulnerability - 漏洞对象
   * @param {Object} context - 上下文信息
   * @returns {number} - 置信度 (0-1)
   */
  calculateConfidence(vulnerability, context) {
    let confidence = this.confidenceFactors.patternMatch;
    
    // 检查上下文匹配
    if (context && context.fileContext) {
      const contextMatches = this.checkContextMatch(vulnerability, context.fileContext);
      if (contextMatches) {
        confidence += this.confidenceFactors.contextMatch;
      }
    }
    
    // 检查规则一致性
    if (this.checkRuleConsistency(vulnerability)) {
      confidence += this.confidenceFactors.ruleConsistency;
    }
    
    // 确保置信度不超过1.0
    return Math.min(1.0, confidence);
  }

  /**
   * 检查上下文匹配
   * @param {Object} vulnerability - 漏洞对象
   * @param {string} fileContext - 文件上下文
   * @returns {boolean} - 是否匹配
   */
  checkContextMatch(vulnerability, fileContext) {
    if (!fileContext) return false;
    
    const ruleId = vulnerability.ruleId || '';
    const lowerContext = fileContext.toLowerCase();
    
    // 检查上下文规则匹配
    for (const [contextType, vulnTypes] of Object.entries(this.contextRules)) {
      if (lowerContext.includes(contextType)) {
        return vulnTypes.some(type => 
          ruleId.toLowerCase().includes(type) || 
          (vulnerability.description || '').toLowerCase().includes(type)
        );
      }
    }
    
    return false;
  }

  /**
   * 检查规则一致性
   * @param {Object} vulnerability - 漏洞对象
   * @returns {boolean} - 是否一致
   */
  checkRuleConsistency(vulnerability) {
    // 简单的一致性检查：检查漏洞类型与描述是否匹配
    const ruleId = (vulnerability.ruleId || '').toLowerCase();
    const description = (vulnerability.description || '').toLowerCase();
    
    // 如果规则ID和描述中都包含相同的关键字，则认为一致
    const keywords = ['xss', 'sql', 'injection', 'csrf', 'session', 'auth', 'file'];
    return keywords.some(keyword => 
      ruleId.includes(keyword) && description.includes(keyword)
    );
  }

  /**
   * 分析上下文影响
   * @param {Object} vulnerability - 漏洞对象
   * @param {Object} context - 上下文信息
   * @returns {Object} - 上下文影响分析
   */
  analyzeContextImpact(vulnerability, context) {
    const impact = {
      severityMultiplier: 1.0,
      affectedComponents: [],
      potentialSpread: 'low',
      remediationDifficulty: 'medium'
    };
    
    if (context && context.fileContext) {
      const lowerContext = context.fileContext.toLowerCase();
      
      // 分析受影响的组件
      if (lowerContext.includes('api') || lowerContext.includes('endpoint')) {
        impact.affectedComponents.push('API');
      }
      if (lowerContext.includes('auth') || lowerContext.includes('login')) {
        impact.affectedComponents.push('Authentication');
        impact.severityMultiplier = Math.min(1.5, impact.severityMultiplier * 1.3);
      }
      if (lowerContext.includes('payment') || lowerContext.includes('billing')) {
        impact.affectedComponents.push('Payment');
        impact.severityMultiplier = Math.min(1.5, impact.severityMultiplier * 1.4);
      }
      if (lowerContext.includes('admin') || lowerContext.includes('manage')) {
        impact.affectedComponents.push('Admin Panel');
        impact.severityMultiplier = Math.min(1.5, impact.severityMultiplier * 1.3);
      }
    }
    
    // 分析潜在传播风险
    if (vulnerability.description && 
        (vulnerability.description.toLowerCase().includes('remote') ||
         vulnerability.description.toLowerCase().includes('execute'))) {
      impact.potentialSpread = 'high';
    } else if (vulnerability.description && 
               vulnerability.description.toLowerCase().includes('access')) {
      impact.potentialSpread = 'medium';
    }
    
    // 分析修复难度
    if (vulnerability.ruleId && 
        (vulnerability.ruleId.toLowerCase().includes('arch') ||
         vulnerability.ruleId.toLowerCase().includes('design'))) {
      impact.remediationDifficulty = 'high';
    } else if (vulnerability.ruleId && 
               vulnerability.ruleId.toLowerCase().includes('config')) {
      impact.remediationDifficulty = 'low';
    }
    
    return impact;
  }

  /**
   * 确定严重性级别
   * @param {number} riskScore - 风险评分
   * @returns {string} - 严重性级别
   */
  determineSeverityLevel(riskScore) {
    if (riskScore >= 0.8) return 'Critical';
    if (riskScore >= 0.6) return 'High';
    if (riskScore >= 0.4) return 'Medium';
    if (riskScore >= 0.2) return 'Low';
    return 'Info';
  }

  /**
   * 分析漏洞关联
   * @param {Array} vulnerabilities - 漏洞数组
   * @param {Object} context - 上下文信息
   * @returns {Object} - 关联分析结果
   */
  analyzeCorrelations(vulnerabilities, context) {
    const correlations = [];
    const enhancedVulns = [...vulnerabilities];
    
    // 对于大量漏洞，使用采样方法避免O(n²)复杂度过高
    const maxVulnsToProcess = 1000; // 限制处理的最大漏洞数
    
    if (vulnerabilities.length > maxVulnsToProcess) {
      // 如果漏洞过多，随机采样一部分进行关联分析
      const sampledVulns = this.sampleVulnerabilities(vulnerabilities, maxVulnsToProcess);
      const sampledIndices = sampledVulns.map(v => vulnerabilities.indexOf(v));
      
      // 检查采样的漏洞之间的关联
      for (let i = 0; i < sampledVulns.length; i++) {
        for (let j = i + 1; j < sampledVulns.length; j++) {
          const vuln1 = sampledVulns[i];
          const vuln2 = sampledVulns[j];
          
          const correlation = this.findCorrelation(vuln1, vuln2);
          if (correlation) {
            correlations.push({
              ...correlation,
              vulnerability1: vuln1,
              vulnerability2: vuln2,
              strength: correlation.strength
            });
            
            // 增强相关漏洞的信息
            this.enhanceRelatedVulnerabilities(vuln1, vuln2, correlation.strength, enhancedVulns);
          }
        }
      }
      
      console.log(`Correlation analysis performed on ${maxVulnsToProcess} sampled vulnerabilities out of ${vulnerabilities.length} total`);
    } else {
      // 漏洞数量适中时，执行完整的关联分析
      for (let i = 0; i < vulnerabilities.length; i++) {
        for (let j = i + 1; j < vulnerabilities.length; j++) {
          const vuln1 = vulnerabilities[i];
          const vuln2 = vulnerabilities[j];
          
          const correlation = this.findCorrelation(vuln1, vuln2);
          if (correlation) {
            correlations.push({
              ...correlation,
              vulnerability1: vuln1,
              vulnerability2: vuln2,
              strength: correlation.strength
            });
            
            // 增强相关漏洞的信息
            this.enhanceRelatedVulnerabilities(vuln1, vuln2, correlation.strength, enhancedVulns);
          }
        }
      }
    }
    
    return {
      vulnerabilities: enhancedVulns,
      correlations,
      totalCorrelations: correlations.length
    };
  }

  /**
   * 从漏洞数组中随机采样指定数量的漏洞
   * @param {Array} vulnerabilities - 漏洞数组
   * @param {number} count - 采样数量
   * @returns {Array} - 采样的漏洞数组
   */
  sampleVulnerabilities(vulnerabilities, count) {
    if (vulnerabilities.length <= count) {
      return vulnerabilities;
    }
    
    const sampled = [];
    const indices = new Set();
    
    while (sampled.length < count) {
      const randomIndex = Math.floor(Math.random() * vulnerabilities.length);
      if (!indices.has(randomIndex)) {
        indices.add(randomIndex);
        sampled.push(vulnerabilities[randomIndex]);
      }
    }
    
    return sampled;
  }

  /**
   * 查找两个漏洞之间的关联
   * @param {Object} vuln1 - 第一个漏洞
   * @param {Object} vuln2 - 第二个漏洞
   * @returns {Object|null} - 关联信息或null
   */
  findCorrelation(vuln1, vuln2) {
    const ruleId1 = (vuln1.ruleId || '').toLowerCase();
    const ruleId2 = (vuln2.ruleId || '').toLowerCase();
    
    // 检查预定义的关联规则
    for (const rule of this.correlationRules) {
      if ((rule.primary === ruleId1 && rule.secondary === ruleId2) ||
          (rule.primary === ruleId2 && rule.secondary === ruleId1)) {
        return rule;
      }
    }
    
    // 基于相似性的启发式关联
    if (this.isSimilarVulnerabilities(vuln1, vuln2)) {
      return {
        primary: ruleId1,
        secondary: ruleId2,
        strength: 0.3,
        description: 'Similar vulnerability types detected in close proximity'
      };
    }
    
    return null;
  }

  /**
   * 检查两个漏洞是否相似
   * @param {Object} vuln1 - 第一个漏洞
   * @param {Object} vuln2 - 第二个漏洞
   * @returns {boolean} - 是否相似
   */
  isSimilarVulnerabilities(vuln1, vuln2) {
    const file1 = vuln1.file || '';
    const file2 = vuln2.file || '';
    const ruleId1 = (vuln1.ruleId || '').toLowerCase();
    const ruleId2 = (vuln2.ruleId || '').toLowerCase();
    
    // 检查是否在同一文件或相似文件中
    if (file1 === file2 || this.isSimilarFiles(file1, file2)) {
      // 检查漏洞类型是否相似
      const commonPatterns = ['xss', 'injection', 'auth', 'session'];
      return commonPatterns.some(pattern => 
        ruleId1.includes(pattern) && ruleId2.includes(pattern)
      );
    }
    
    return false;
  }

  /**
   * 检查两个文件名是否相似
   * @param {string} file1 - 第一个文件名
   * @param {string} file2 - 第二个文件名
   * @returns {boolean} - 是否相似
   */
  isSimilarFiles(file1, file2) {
    const name1 = file1.replace(/\.[^/.]+$/, ""); // 移除扩展名
    const name2 = file2.replace(/\.[^/.]+$/, ""); // 移除扩展名
    
    // 检查基本名称是否相同或一个包含另一个
    return name1 === name2 || name1.includes(name2) || name2.includes(name1);
  }

  /**
   * 增强相关漏洞的信息
   * @param {Object} vuln1 - 第一个漏洞
   * @param {Object} vuln2 - 第二个漏洞
   * @param {number} correlationStrength - 关联强度
   * @param {Array} vulnerabilities - 漏洞数组（会被修改）
   */
  enhanceRelatedVulnerabilities(vuln1, vuln2, correlationStrength, vulnerabilities) {
    // 提高相关漏洞的风险评分
    const vuln1Idx = vulnerabilities.findIndex(v => v === vuln1);
    const vuln2Idx = vulnerabilities.findIndex(v => v === vuln2);
    
    if (vuln1Idx !== -1 && vulnerabilities[vuln1Idx].riskScore) {
      vulnerabilities[vuln1Idx].riskScore = Math.min(1.0, 
        vulnerabilities[vuln1Idx].riskScore + (correlationStrength * 0.1));
      vulnerabilities[vuln1Idx].isCorrelated = true;
    }
    
    if (vuln2Idx !== -1 && vulnerabilities[vuln2Idx].riskScore) {
      vulnerabilities[vuln2Idx].riskScore = Math.min(1.0, 
        vulnerabilities[vuln2Idx].riskScore + (correlationStrength * 0.1));
      vulnerabilities[vuln2Idx].isCorrelated = true;
    }
  }

  /**
   * 生成智能分析摘要
   * @param {Array} vulnerabilities - 漏洞数组
   * @param {Object} context - 上下文信息
   * @returns {Object} - 分析摘要
   */
  generateAnalysisSummary(vulnerabilities, context) {
    const analyzedVulns = this.analyzeVulnerabilities(vulnerabilities, context);
    
    // 统计信息
    const stats = {
      totalVulnerabilities: analyzedVulns.length,
      bySeverity: {},
      byType: {},
      averageRiskScore: 0,
      highRiskVulnerabilities: 0
    };
    
    let totalRiskScore = 0;
    
    analyzedVulns.forEach(vuln => {
      // 按严重性统计
      const severity = vuln.severityLevel || 'Medium';
      stats.bySeverity[severity] = (stats.bySeverity[severity] || 0) + 1;
      
      // 按类型统计
      const type = vuln.ruleId || 'Unknown';
      stats.byType[type] = (stats.byType[type] || 0) + 1;
      
      // 累计风险评分
      if (vuln.riskScore !== undefined) {
        totalRiskScore += vuln.riskScore;
        if (vuln.riskScore >= this.options.riskThreshold) {
          stats.highRiskVulnerabilities++;
        }
      }
    });
    
    if (analyzedVulns.length > 0 && totalRiskScore > 0) {
      stats.averageRiskScore = totalRiskScore / analyzedVulns.length;
    }
    
    // 高风险漏洞列表
    const highRiskVulns = analyzedVulns.filter(vuln => 
      vuln.riskScore >= this.options.riskThreshold
    );
    
    return {
      statistics: stats,
      highRiskVulnerabilities: highRiskVulns,
      recommendations: this.generateRecommendations(highRiskVulns, stats),
      summary: `Analysis completed for ${analyzedVulns.length} vulnerabilities. ` +
               `${stats.highRiskVulnerabilities} high-risk vulnerabilities identified. ` +
               `Average risk score: ${(stats.averageRiskScore * 100).toFixed(1)}%.`
    };
  }

  /**
   * 生成修复建议
   * @param {Array} highRiskVulns - 高风险漏洞数组
   * @param {Object} stats - 统计信息
   * @returns {Array} - 修复建议数组
   */
  generateRecommendations(highRiskVulns, stats) {
    const recommendations = [];
    
    // 按类型分组提供建议
    const byType = {};
    highRiskVulns.forEach(vuln => {
      const type = vuln.ruleId || 'Unknown';
      if (!byType[type]) {
        byType[type] = [];
      }
      byType[type].push(vuln);
    });
    
    for (const [type, vulns] of Object.entries(byType)) {
      recommendations.push({
        vulnerabilityType: type,
        count: vulns.length,
        recommendation: this.getRecommendationForType(type),
        priority: this.getPriorityForType(type)
      });
    }
    
    return recommendations;
  }

  /**
   * 获取特定类型漏洞的修复建议
   * @param {string} type - 漏洞类型
   * @returns {string} - 修复建议
   */
  getRecommendationForType(type) {
    const recommendations = {
      'xss': 'Implement proper input sanitization and output encoding. Use frameworks\' built-in XSS protection mechanisms.',
      'sql-injection': 'Use parameterized queries or prepared statements. Validate and sanitize all user inputs.',
      'csrf': 'Implement CSRF tokens for state-changing operations. Use SameSite cookies where appropriate.',
      'ssrf': 'Validate and sanitize URLs before making requests. Use allowlists for permitted domains.',
      'deserialization': 'Avoid deserializing data from untrusted sources. Use safe serialization formats.',
      'file-inclusion': 'Validate file paths and restrict access to specific directories. Use allowlists for file types.'
    };
    
    return recommendations[type.toLowerCase()] || 
           'Review the vulnerable code and apply appropriate security controls based on the specific vulnerability.';
  }

  /**
   * 获取特定类型漏洞的处理优先级
   * @param {string} type - 漏洞类型
   * @returns {string} - 优先级
   */
  getPriorityForType(type) {
    const priorities = {
      'sql-injection': 'critical',
      'deserialization': 'critical',
      'ssrf': 'high',
      'xss': 'high',
      'csrf': 'medium',
      'file-inclusion': 'high'
    };
    
    return priorities[type.toLowerCase()] || 'medium';
  }
}

module.exports = IntelligentVulnerabilityAnalyzer;