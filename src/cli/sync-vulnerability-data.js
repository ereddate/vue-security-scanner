#!/usr/bin/env node

const VulnerabilityDataManager = require('../core/vulnerability-data-manager');
const vulnerabilityDataConfig = require('../config/vulnerability-data');
const NVDataSource = require('../core/data-sources/nvd-data-source');
const GitHubAdvisoryDataSource = require('../core/data-sources/github-advisory-data-source');
const VueEcosystemDataSource = require('../core/data-sources/vue-ecosystem-data-source');

class VulnerabilityDataSyncCommand {
  constructor() {
    this.dataManager = null;
  }

  async run(options = {}) {
    try {
      console.log('Vue Security Scanner - Vulnerability Data Sync');
      console.log('==========================================\n');

      this.dataManager = new VulnerabilityDataManager({
        storagePath: options.storagePath || vulnerabilityDataConfig.getStoragePath()
      });

      if (options.config) {
        this.printConfig();
        return;
      }

      if (options.stats) {
        await this.showStatistics();
        return;
      }

      if (options.clear) {
        await this.clearData();
        return;
      }

      if (options.search) {
        await this.searchVulnerabilities(options.search);
        return;
      }

      if (options.package) {
        await this.checkPackage(options.package, options.version);
        return;
      }

      if (options.cve) {
        await this.checkCVE(options.cve);
        return;
      }

      await this.syncData(options);

    } catch (error) {
      console.error('Error during vulnerability data sync:', error.message);
      process.exit(1);
    }
  }

  async syncData(options) {
    console.log('Starting vulnerability data synchronization...\n');

    const dataSources = vulnerabilityDataConfig.getConfig().dataSources;
    
    if (options.sources) {
      const selectedSources = options.sources.split(',').map(s => s.trim().toLowerCase());
      
      for (const sourceName of selectedSources) {
        if (dataSources[sourceName] && dataSources[sourceName].enabled) {
          this.registerDataSource(sourceName, dataSources[sourceName]);
        } else {
          console.warn(`Data source '${sourceName}' is not available or disabled`);
        }
      }
    } else {
      for (const [name, config] of Object.entries(dataSources)) {
        if (config.enabled) {
          this.registerDataSource(name, config);
        }
      }
    }

    const startTime = Date.now();
    await this.dataManager.syncAllDataSources();
    const duration = ((Date.now() - startTime) / 1000).toFixed(2);

    console.log(`\nSynchronization completed in ${duration}s`);
    
    const stats = this.dataManager.getStatistics();
    console.log(`Total vulnerabilities: ${stats.totalVulnerabilities}`);
    console.log(`Data sources: ${stats.dataSources}`);
    console.log(`Last update: ${stats.lastUpdate ? stats.lastUpdate.toISOString() : 'Never'}`);
  }

  registerDataSource(name, config) {
    switch (name) {
      case 'nvd':
        this.dataManager.registerDataSource('nvd', new NVDataSource(config));
        break;
      case 'github':
        this.dataManager.registerDataSource('github', new GitHubAdvisoryDataSource(config));
        break;
      case 'vue':
        this.dataManager.registerDataSource('vue', new VueEcosystemDataSource(config));
        break;
      default:
        console.warn(`Unknown data source: ${name}`);
    }
  }

  async showStatistics() {
    console.log('Vulnerability Data Statistics');
    console.log('=============================\n');

    const stats = this.dataManager.getStatistics();
    
    console.log(`Total Vulnerabilities: ${stats.totalVulnerabilities}`);
    console.log(`Data Sources: ${stats.dataSources}`);
    console.log(`Last Update: ${stats.lastUpdate ? stats.lastUpdate.toISOString() : 'Never'}`);
    console.log('\nVulnerabilities by Source:');
    
    for (const [source, count] of Object.entries(stats.vulnerabilitiesBySource)) {
      console.log(`  ${source}: ${count}`);
    }
    
    console.log('\nVulnerabilities by Severity:');
    for (const [severity, count] of Object.entries(stats.vulnerabilitiesBySeverity)) {
      console.log(`  ${severity}: ${count}`);
    }
  }

  async clearData() {
    console.log('Clearing vulnerability data cache...');
    await this.dataManager.clearCache();
    console.log('Cache cleared successfully');
  }

  async searchVulnerabilities(query) {
    console.log(`Searching for vulnerabilities: ${query}\n`);
    
    const results = this.dataManager.searchVulnerabilities(query);
    
    if (results.length === 0) {
      console.log('No vulnerabilities found');
      return;
    }
    
    console.log(`Found ${results.length} vulnerabilities:\n`);
    
    results.forEach((vuln, index) => {
      console.log(`${index + 1}. ${vuln.title || vuln.id}`);
      console.log(`   Severity: ${vuln.severity}`);
      console.log(`   Source: ${vuln.source}`);
      if (vuln.cveId) {
        console.log(`   CVE: ${vuln.cveId}`);
      }
      if (vuln.packageName) {
        console.log(`   Package: ${vuln.packageName}`);
      }
      console.log(`   Description: ${vuln.description ? vuln.description.substring(0, 100) + '...' : 'N/A'}`);
      console.log();
    });
  }

  async checkPackage(packageName, version) {
    console.log(`Checking vulnerabilities for package: ${packageName}${version ? `@${version}` : ''}\n`);
    
    const vulnerabilities = this.dataManager.findVulnerabilitiesForDependency(packageName, version);
    
    if (vulnerabilities.length === 0) {
      console.log('No vulnerabilities found for this package');
      return;
    }
    
    console.log(`Found ${vulnerabilities.length} vulnerabilities:\n`);
    
    vulnerabilities.forEach((vuln, index) => {
      console.log(`${index + 1}. ${vuln.title || vuln.id}`);
      console.log(`   Severity: ${vuln.severity}`);
      console.log(`   Source: ${vuln.source}`);
      if (vuln.cveId) {
        console.log(`   CVE: ${vuln.cveId}`);
      }
      if (vuln.affectedVersions && vuln.affectedVersions.length > 0) {
        console.log(`   Affected Versions: ${vuln.affectedVersions.join(', ')}`);
      }
      console.log(`   Description: ${vuln.description ? vuln.description.substring(0, 100) + '...' : 'N/A'}`);
      console.log();
    });
  }

  async checkCVE(cveId) {
    console.log(`Checking vulnerability: ${cveId}\n`);
    
    const vulnerability = this.dataManager.getVulnerabilityDetails(cveId);
    
    if (!vulnerability) {
      console.log('Vulnerability not found in database');
      console.log('Try running sync to update the database');
      return;
    }
    
    console.log(`Title: ${vulnerability.title || vulnerability.id}`);
    console.log(`Severity: ${vulnerability.severity}`);
    console.log(`Source: ${vulnerability.source}`);
    console.log(`Published: ${vulnerability.publishedDate || 'N/A'}`);
    console.log(`Modified: ${vulnerability.modifiedDate || 'N/A'}`);
    console.log(`\nDescription:\n${vulnerability.description || 'N/A'}`);
    
    if (vulnerability.packageName) {
      console.log(`\nPackage: ${vulnerability.packageName}`);
    }
    
    if (vulnerability.affectedVersions && vulnerability.affectedVersions.length > 0) {
      console.log(`\nAffected Versions: ${vulnerability.affectedVersions.join(', ')}`);
    }
    
    if (vulnerability.references && vulnerability.references.length > 0) {
      console.log('\nReferences:');
      vulnerability.references.forEach(ref => {
        console.log(`  - ${ref.url} (${ref.source})`);
      });
    }
  }

  printConfig() {
    vulnerabilityDataConfig.printConfig();
  }
}

if (require.main === module) {
  const command = new VulnerabilityDataSyncCommand();
  
  const args = process.argv.slice(2);
  const options = {};
  
  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (arg.startsWith('--')) {
      const key = arg.substring(2);
      const nextArg = args[i + 1];
      
      if (nextArg && !nextArg.startsWith('--')) {
        options[key] = nextArg;
        i++;
      } else {
        options[key] = true;
      }
    }
  }
  
  command.run(options);
}

module.exports = VulnerabilityDataSyncCommand;
