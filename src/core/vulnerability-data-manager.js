const path = require('path');
const fs = require('fs-extra');

class VulnerabilityDataManager {
  constructor(config = {}) {
    this.config = config;
    this.dataSources = {};
    this.vulnerabilityDatabase = new Map();
    this.lastUpdate = null;
    this.storagePath = config.storagePath || path.join(process.cwd(), 'data', 'vulnerability-db.json');
    
    this.initializeStorage();
  }

  initializeStorage() {
    try {
      const dataDir = path.dirname(this.storagePath);
      if (!fs.existsSync(dataDir)) {
        fs.ensureDirSync(dataDir);
      }
      
      if (fs.existsSync(this.storagePath)) {
        const data = fs.readJsonSync(this.storagePath);
        this.vulnerabilityDatabase = new Map(Object.entries(data));
        this.lastUpdate = data.lastUpdate ? new Date(data.lastUpdate) : null;
      }
    } catch (error) {
      console.warn('Failed to initialize vulnerability data storage:', error.message);
    }
  }

  registerDataSource(name, dataSource) {
    this.dataSources[name] = dataSource;
    console.log(`Registered data source: ${name}`);
  }

  async syncAllDataSources() {
    console.log('Starting vulnerability data synchronization...');
    const syncPromises = Object.entries(this.dataSources).map(async ([name, dataSource]) => {
      try {
        const data = await dataSource.fetchData();
        this.processDataSourceData(name, data);
        console.log(`Successfully synced data from ${name}`);
      } catch (error) {
        console.warn(`Failed to sync data from ${name}:`, error.message);
      }
    });

    await Promise.all(syncPromises);
    this.lastUpdate = new Date();
    await this.saveToStorage();
    console.log('Vulnerability data synchronization completed');
  }

  processDataSourceData(sourceName, data) {
    if (!data || !Array.isArray(data)) {
      return;
    }

    data.forEach(vuln => {
      const key = this.getVulnerabilityKey(vuln);
      if (!this.vulnerabilityDatabase.has(key)) {
        this.vulnerabilityDatabase.set(key, {
          ...vuln,
          source: sourceName,
          syncedAt: new Date()
        });
      }
    });
  }

  getVulnerabilityKey(vuln) {
    if (vuln.cveId) {
      return `cve-${vuln.cveId}`;
    }
    if (vuln.id) {
      return vuln.id;
    }
    if (vuln.packageName && vuln.version) {
      return `dep-${vuln.packageName}-${vuln.version}`;
    }
    return `vuln-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  findVulnerabilitiesForDependency(packageName, version) {
    const vulnerabilities = [];
    
    this.vulnerabilityDatabase.forEach(vuln => {
      if (vuln.packageName === packageName) {
        if (!version || this.isVersionAffected(version, vuln)) {
          vulnerabilities.push(vuln);
        }
      }
    });
    
    return vulnerabilities;
  }

  isVersionAffected(version, vuln) {
    if (!vuln.affectedVersions || vuln.affectedVersions.length === 0) {
      return true;
    }
    
    return vuln.affectedVersions.some(affectedRange => {
      return this.satisfiesVersionRange(version, affectedRange);
    });
  }

  satisfiesVersionRange(version, range) {
    try {
      const semver = require('semver');
      return semver.satisfies(version, range);
    } catch (error) {
      return false;
    }
  }

  getVulnerabilityDetails(cveId) {
    return this.vulnerabilityDatabase.get(`cve-${cveId}`);
  }

  searchVulnerabilities(query) {
    const results = [];
    const lowerQuery = query.toLowerCase();
    
    this.vulnerabilityDatabase.forEach(vuln => {
      const searchableText = `${vuln.title || ''} ${vuln.description || ''} ${vuln.packageName || ''}`.toLowerCase();
      if (searchableText.includes(lowerQuery)) {
        results.push(vuln);
      }
    });
    
    return results;
  }

  async saveToStorage() {
    try {
      const data = {
        vulnerabilities: Object.fromEntries(this.vulnerabilityDatabase),
        lastUpdate: this.lastUpdate,
        version: '1.0.0'
      };
      await fs.writeJson(this.storagePath, data);
    } catch (error) {
      console.warn('Failed to save vulnerability data to storage:', error.message);
    }
  }

  getStatistics() {
    const stats = {
      totalVulnerabilities: this.vulnerabilityDatabase.size,
      dataSources: Object.keys(this.dataSources).length,
      lastUpdate: this.lastUpdate,
      vulnerabilitiesBySource: {},
      vulnerabilitiesBySeverity: {
        Critical: 0,
        High: 0,
        Medium: 0,
        Low: 0
      }
    };

    this.vulnerabilityDatabase.forEach(vuln => {
      const source = vuln.source || 'unknown';
      stats.vulnerabilitiesBySource[source] = (stats.vulnerabilitiesBySource[source] || 0) + 1;
      
      const severity = vuln.severity || 'Medium';
      if (stats.vulnerabilitiesBySeverity[severity] !== undefined) {
        stats.vulnerabilitiesBySeverity[severity]++;
      }
    });

    return stats;
  }

  getLastUpdateTime() {
    return this.lastUpdate;
  }

  async clearCache() {
    this.vulnerabilityDatabase.clear();
    this.lastUpdate = null;
    await this.saveToStorage();
    console.log('Vulnerability data cache cleared');
  }
}

module.exports = VulnerabilityDataManager;
