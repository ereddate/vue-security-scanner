// src/core/vulnerability-detector.js
// 漏洞检测核心模块

const { checkForXSS, checkForInsecureDependencies, checkForMisconfigurations } = require('../checks/security-checks');
const { ErrorHandler } = require('../utils/error-handler');
const pluginManager = require('../plugin-system/plugin-manager');

class VulnerabilityDetector {
  constructor(config = {}) {
    this.config = config;
    this.enabledChecks = this.initializeChecks();
  }

  initializeChecks() {
    const checks = {};
    
    // XSS检查
    if (this.config.rules?.xss?.enabled !== false) {
      checks.xss = checkForXSS;
    }
    
    // 依赖安全检查
    if (this.config.rules?.dependencies?.enabled !== false) {
      checks.dependencies = checkForInsecureDependencies;
    }
    
    // 配置安全检查
    if (this.config.rules?.configSecurity?.enabled !== false) {
      checks.misconfigurations = checkForMisconfigurations;
    }
    
    return checks;
  }

  async detectVulnerabilities(filePath, content) {
    let vulnerabilities = [];
    
    try {
      // 首次运行时自动加载插件
      if (!this.pluginsLoaded) {
        await pluginManager.loadPluginsFromDirectory('./plugins');
        this.pluginsLoaded = true;
      }
      
      // 执行内置检查
      for (const [checkName, checkFunction] of Object.entries(this.enabledChecks)) {
        try {
          const checkVulns = checkFunction(filePath, content);
          vulnerabilities.push(...checkVulns);
        } catch (error) {
          console.warn(`Error in ${checkName} check for ${filePath}:`, error.message);
          // 继续执行其他检查，不要因为一个检查失败而停止整个扫描
        }
      }
      
      // 执行插件检查
      const pluginVulns = await pluginManager.runPlugins(filePath, content);
      vulnerabilities.push(...pluginVulns);
      
    } catch (error) {
      const handledError = ErrorHandler.handleFileError(filePath, error);
      console.error(`Failed to detect vulnerabilities in ${filePath}:`, handledError.message);
    }
    
    return vulnerabilities;
  }

  // 添加单个检查方法
  async runSpecificCheck(checkName, filePath, content) {
    if (!this.enabledChecks[checkName]) {
      throw new Error(`Check ${checkName} is not available or enabled`);
    }
    
    try {
      return this.enabledChecks[checkName](filePath, content);
    } catch (error) {
      const handledError = ErrorHandler.handleFileError(filePath, error);
      console.error(`Error running ${checkName} check on ${filePath}:`, handledError.message);
      return [];
    }
  }

  updateConfig(newConfig) {
    this.config = { ...this.config, ...newConfig };
    this.enabledChecks = this.initializeChecks();
  }
  
  // 插件管理方法
  registerPlugin(name, plugin) {
    pluginManager.registerPlugin(name, plugin);
  }
  
  enablePlugin(name) {
    pluginManager.enablePlugin(name);
  }
  
  disablePlugin(name) {
    pluginManager.disablePlugin(name);
  }
  
  getPluginsInfo() {
    return pluginManager.getPluginsInfo();
  }
}

module.exports = VulnerabilityDetector;