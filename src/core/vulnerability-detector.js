// src/core/vulnerability-detector.js
// 漏洞检测核心模块 - 增强版

const path = require('path');
const { ErrorHandler } = require('../utils/error-handler');
const { analyzeWithAdvancedRules, analyzeWithRulesLimited } = require('../rules/rule-engine');
const IgnoreManager = require('../utils/ignore-manager');
const ASTAnalyzer = require('../analysis/ast-analyzer');

class VulnerabilityDetector {
  constructor(config = {}) {
    this.config = config;
    this.ignoreManager = null;
    this.enableAdvancedAnalysis = config.enableAdvancedAnalysis !== false;
    this.maxVulnerabilitiesPerFile = config.maxVulnerabilitiesPerFile || 50;
    this.enableSemanticAnalysis = config.enableSemanticAnalysis !== false;
    this.astAnalyzer = new ASTAnalyzer({ enableSemanticAnalysis: this.enableSemanticAnalysis });
  }

  async detectVulnerabilities(filePath, content, projectPath = '.') {
    let vulnerabilities = [];
    
    try {
      if (!this.ignoreManager) {
        this.ignoreManager = new IgnoreManager(path.resolve(projectPath));
      }
      
      // 使用增强分析或标准分析（正则表达式）
      if (this.enableAdvancedAnalysis) {
        const checkVulns = analyzeWithAdvancedRules(filePath, content, this.maxVulnerabilitiesPerFile);
        vulnerabilities.push(...checkVulns);
      } else {
        const checkVulns = analyzeWithRulesLimited(filePath, content, this.maxVulnerabilitiesPerFile);
        vulnerabilities.push(...checkVulns);
      }
      
      // 使用AST语义分析（增强检测准确率）
      if (this.enableSemanticAnalysis) {
        const semanticVulns = this.astAnalyzer.analyze(filePath, content);
        
        // 合并正则和AST分析结果，去重
        const mergedVulns = this.mergeVulnerabilities(vulnerabilities, semanticVulns);
        vulnerabilities = mergedVulns;
      }
      
      // 过滤掉应该被忽略的漏洞
      vulnerabilities = vulnerabilities.filter(vuln => {
        return !this.ignoreManager.shouldIgnoreVulnerability(vuln);
      });
      
      // 对漏洞进行后处理和增强分析
      vulnerabilities = this.enhanceVulnerabilities(vulnerabilities, filePath, content);
      
    } catch (error) {
      const handledError = ErrorHandler.handleFileError(filePath, error);
      console.error(`Failed to detect vulnerabilities in ${filePath}:`, handledError.message);
    }
    
    return vulnerabilities;
  }

  mergeVulnerabilities(regexVulns, semanticVulns) {
    const merged = [...regexVulns];
    const seen = new Set();
    
    // 标记正则表达式检测到的漏洞
    regexVulns.forEach(vuln => {
      const key = `${vuln.file}:${vuln.line}:${vuln.ruleId}`;
      seen.add(key);
    });
    
    // 添加AST检测到的新漏洞（去重）
    semanticVulns.forEach(vuln => {
      const key = `${vuln.file}:${vuln.line}:${vuln.ruleId}`;
      if (!seen.has(key)) {
        merged.push(vuln);
        seen.add(key);
      }
    });
    
    return merged;
  }

  enhanceVulnerabilities(vulnerabilities, filePath, content) {
    return vulnerabilities.map(vuln => {
      // 添加额外的上下文信息
      let enhancedVuln = { ...vuln };
      
      // 添加文件类型信息
      enhancedVuln.fileType = path.extname(filePath).toLowerCase();
      
      // 添加框架特定信息
      if (enhancedVuln.fileType === '.vue' || enhancedVuln.fileType === '.nvue') {
        enhancedVuln.framework = 'Vue.js';
        const vueAnalysis = this.analyzeVueSpecificIssues(enhancedVuln, content);
        enhancedVuln = { ...enhancedVuln, ...vueAnalysis };
      } else if (enhancedVuln.fileType === '.js' || enhancedVuln.fileType === '.jsx') {
        enhancedVuln.framework = 'JavaScript';
        const jsAnalysis = this.analyzeJSSpecificIssues(enhancedVuln, content);
        enhancedVuln = { ...enhancedVuln, ...jsAnalysis };
      } else if (enhancedVuln.fileType === '.wxml' || enhancedVuln.fileType === '.wxss' || enhancedVuln.fileType === '.wxs') {
        enhancedVuln.framework = 'WeChat Mini Program';
        const miniAppAnalysis = this.analyzeMiniAppSpecificIssues(enhancedVuln, content);
        enhancedVuln = { ...enhancedVuln, ...miniAppAnalysis };
      } else if (enhancedVuln.fileType === '.json') {
        enhancedVuln.framework = this.detectFrameworkFromJSON(filePath, content);
      } else if (enhancedVuln.fileType === '.tsx' || enhancedVuln.fileType === '.jsx') {
        // 检测Taro框架
        if (filePath.includes('app.tsx') || filePath.includes('app.jsx') || content.includes('@tarojs')) {
          enhancedVuln.framework = 'Taro';
          const taroAnalysis = this.analyzeTaroSpecificIssues(enhancedVuln, content);
          enhancedVuln = { ...enhancedVuln, ...taroAnalysis };
        } else {
          enhancedVuln.framework = 'React';
        }
      } else if (enhancedVuln.fileType === '.html' || enhancedVuln.fileType === '.swan' || enhancedVuln.fileType === '.ttml' || enhancedVuln.fileType === '.qml') {
        enhancedVuln.framework = this.detectFrameworkFromMarkup(filePath, content);
      }
      
      // 添加 CWE (Common Weakness Enumeration) 参考信息
      enhancedVuln.cwe = this.mapToCWE(enhancedVuln.ruleId);
      
      // 添加 OWASP Top 10 参考信息
      enhancedVuln.owaspCategory = this.mapToOWASP(enhancedVuln.ruleId);
      
      // 添加修复复杂度评估
      enhancedVuln.fixComplexity = this.assessFixComplexity(enhancedVuln);
      
      return enhancedVuln;
    });
  }

  analyzeVueSpecificIssues(vuln, content) {
    // Vue特定问题的分析
    const enhanced = { ...vuln };
    
    // 检查是否是Vue 2或Vue 3
    if (content.includes('createApp') || content.includes('defineComponent')) {
      enhanced.vueVersion = '3.x';
    } else if (content.includes('new Vue') || content.includes('Vue.component')) {
      enhanced.vueVersion = '2.x';
    }
    
    // 检查是否使用了Composition API
    if (content.includes('setup()') || content.includes('ref(') || content.includes('reactive(')) {
      enhanced.usesCompositionAPI = true;
    }
    
    // 检查是否使用了TypeScript
    if (content.includes('lang="ts"') || path.extname(vuln.file) === '.ts') {
      enhanced.usesTypeScript = true;
    }
    
    return enhanced;
  }

  analyzeJSSpecificIssues(vuln, content) {
    // JavaScript特定问题的分析
    const enhanced = { ...vuln };
    
    // 检查是否使用了现代JS语法
    if (content.includes('import ') || content.includes('export ')) {
      enhanced.usesESModules = true;
    }
    
    // 检查是否使用了异步操作
    if (content.includes('async ') || content.includes('await ') || content.includes('.then(')) {
      enhanced.usesAsync = true;
    }
    
    return enhanced;
  }

  analyzeMiniAppSpecificIssues(vuln, content) {
    // 小程序特定问题的分析
    const enhanced = { ...vuln };
    
    // 检查是否使用了小程序API
    if (content.includes('wx.') || content.includes('uni.')) {
      enhanced.usesMiniAppAPI = true;
    }
    
    // 检查是否使用了不安全的模板语法
    if (content.includes('{{') && content.includes('}}')) {
      enhanced.usesTemplateInterpolation = true;
    }
    
    return enhanced;
  }

  analyzeTaroSpecificIssues(vuln, content) {
    // Taro特定问题的分析
    const enhanced = { ...vuln };
    
    // 检查是否使用了Taro API
    if (content.includes('Taro.') || content.includes('@tarojs/')) {
      enhanced.usesTaroAPI = true;
    }
    
    // 检查是否使用了Taro导航API
    if (content.includes('Taro.navigateTo') || content.includes('Taro.redirectTo') || content.includes('Taro.switchTab')) {
      enhanced.usesTaroNavigation = true;
    }
    
    // 检查是否使用了Taro网络请求API
    if (content.includes('Taro.request')) {
      enhanced.usesTaroNetwork = true;
    }
    
    return enhanced;
  }

  detectFrameworkFromJSON(filePath, content) {
    // 从JSON文件检测框架
    try {
      const jsonContent = JSON.parse(content);
      
      // 检测uni-app
      if (filePath.includes('pages.json') || filePath.includes('manifest.json')) {
        if (jsonContent.uniPlatform || jsonContent.appid) {
          return 'uni-app';
        }
      }
      
      // 检测微信小程序
      if (filePath.includes('app.json') || filePath.includes('project.config.json')) {
        if (jsonContent.pages || jsonContent.appid) {
          return 'WeChat Mini Program';
        }
      }
      
      // 检测Taro框架
      if (filePath.includes('app.config.ts') || filePath.includes('app.config.js') || filePath.includes('.config.ts') || filePath.includes('.config.js')) {
        if (jsonContent.pages || jsonContent.window || jsonContent.tabBar) {
          return 'Taro';
        }
      }
      
      // 检测package.json中的框架信息
      if (filePath.includes('package.json')) {
        if (jsonContent.dependencies && jsonContent.dependencies['@tarojs/taro']) {
          return 'Taro';
        }
      }
      
      // 检测其他小程序框架
      if (jsonContent.swanPages) return 'Baidu Smart Program';
      if (jsonContent.ttPages) return 'ByteDance Mini Program';
      if (jsonContent.qmlPages) return 'QQ Mini Program';
      
    } catch (error) {
      // JSON解析失败，返回默认值
    }
    
    return 'Unknown';
  }

  detectFrameworkFromMarkup(filePath, content) {
    // 从标记文件检测框架
    
    // 检测uni-app
    if (filePath.includes('.nvue') || content.includes('uni-app') || content.includes('@uni/')) {
      return 'uni-app';
    }
    
    // 检测微信小程序
    if (filePath.includes('.wxml') || content.includes('wx:') || content.includes('WeixinJSBridge')) {
      return 'WeChat Mini Program';
    }
    
    // 检测百度智能小程序
    if (filePath.includes('.swan') || content.includes('swan:')) {
      return 'Baidu Smart Program';
    }
    
    // 检测字节跳动小程序
    if (filePath.includes('.ttml') || content.includes('tt:')) {
      return 'ByteDance Mini Program';
    }
    
    // 检测QQ小程序
    if (filePath.includes('.qml') || content.includes('qq:')) {
      return 'QQ Mini Program';
    }
    
    // 检测普通HTML
    if (filePath.includes('.html')) {
      return 'HTML';
    }
    
    return 'Unknown';
  }

  mapToCWE(ruleId) {
    // 将规则ID映射到CWE编号
    const cweMapping = {
      'xss-v-html': 'CWE-79',
      'xss-dangerously-set-inner-html': 'CWE-79',
      'hardcoded-password': 'CWE-798',
      'hardcoded-secret': 'CWE-798',
      'sql-injection-sequelize': 'CWE-89',
      'command-injection': 'CWE-78',
      'path-traversal': 'CWE-22',
      'ssrf-vulnerable-request': 'CWE-918',
      'insecure-crypto-algorithm': 'CWE-327',
      'insecure-randomness': 'CWE-338',
      'insecure-storage': 'CWE-922',
      'insecure-communication': 'CWE-319',
      'information-disclosure': 'CWE-200',
      'insecure-direct-object-reference': 'CWE-639',
      'improper-authentication': 'CWE-287',
      'csrf-missing-token': 'CWE-352'
    };
    
    return cweMapping[ruleId] || 'CWE-16'; // 默认为配置问题
  }

  mapToOWASP(ruleId) {
    // 将规则ID映射到OWASP Top 10类别
    const owaspMapping = {
      'xss-v-html': 'A03:2021 – Injection',
      'xss-dangerously-set-inner-html': 'A03:2021 – Injection',
      'sql-injection-sequelize': 'A03:2021 – Injection',
      'command-injection': 'A03:2021 – Injection',
      'hardcoded-password': 'A02:2021 – Cryptographic Failures',
      'hardcoded-secret': 'A02:2021 – Cryptographic Failures',
      'insecure-crypto-algorithm': 'A02:2021 – Cryptographic Failures',
      'insecure-randomness': 'A02:2021 – Cryptographic Failures',
      'insecure-storage': 'A02:2021 – Cryptographic Failures',
      'insecure-communication': 'A02:2021 – Cryptographic Failures',
      'improper-authentication': 'A07:2021 – Identification and Authentication Failures',
      'csrf-missing-token': 'A01:2021 – Broken Access Control',
      'insecure-direct-object-reference': 'A01:2021 – Broken Access Control',
      'path-traversal': 'A01:2021 – Broken Access Control',
      'ssrf-vulnerable-request': 'A10:2021 – Server-Side Request Forgery',
      'information-disclosure': 'A04:2021 – Insecure Design',
      'insecure-dependency': 'A06:2021 – Vulnerable and Outdated Components'
    };
    
    return owaspMapping[ruleId] || 'A05:2021 – Security Misconfiguration';
  }

  assessFixComplexity(vuln) {
    // 评估修复复杂度
    const highComplexityRules = [
      'vue-composition-api',
      'vue-state-security',
      'vue-router-security',
      'ssrf-vulnerable-request',
      'command-injection'
    ];
    
    const mediumComplexityRules = [
      'xss-v-html',
      'sql-injection-sequelize',
      'insecure-crypto-algorithm',
      'insecure-storage'
    ];
    
    if (highComplexityRules.includes(vuln.ruleId)) {
      return 'High';
    } else if (mediumComplexityRules.includes(vuln.ruleId)) {
      return 'Medium';
    } else {
      return 'Low';
    }
  }

  // 添加单个检查方法 - 当前使用统一的漏洞检测函数
  async runSpecificCheck(checkName, filePath, content, projectPath = '.') {
    try {
      const allVulns = this.enableAdvancedAnalysis 
        ? analyzeWithAdvancedRules(filePath, content, this.maxVulnerabilitiesPerFile)
        : analyzeWithRulesLimited(filePath, content, this.maxVulnerabilitiesPerFile);
      
      // 初始化忽略管理器
      if (!this.ignoreManager) {
        this.ignoreManager = new IgnoreManager(path.resolve(projectPath));
      }
      
      // 过滤和增强漏洞
      const filteredVulns = allVulns.filter(vuln => {
        return !this.ignoreManager.shouldIgnoreVulnerability(vuln);
      });
      
      return this.enhanceVulnerabilities(filteredVulns, filePath, content);
    } catch (error) {
      const handledError = ErrorHandler.handleFileError(filePath, error);
      console.error(`Error running vulnerability check on ${filePath}:`, handledError.message);
      return [];
    }
  }

  updateConfig(newConfig) {
    this.config = { ...this.config, ...newConfig };
    
    if (newConfig.enableAdvancedAnalysis !== undefined) {
      this.enableAdvancedAnalysis = newConfig.enableAdvancedAnalysis;
    }
    
    if (newConfig.maxVulnerabilitiesPerFile !== undefined) {
      this.maxVulnerabilitiesPerFile = newConfig.maxVulnerabilitiesPerFile;
    }
    
    if (newConfig.enableSemanticAnalysis !== undefined) {
      this.enableSemanticAnalysis = newConfig.enableSemanticAnalysis;
      this.astAnalyzer = new ASTAnalyzer({ enableSemanticAnalysis: this.enableSemanticAnalysis });
    }
  }

  getDetectionStats() {
    return {
      enableAdvancedAnalysis: this.enableAdvancedAnalysis,
      enableSemanticAnalysis: this.enableSemanticAnalysis,
      maxVulnerabilitiesPerFile: this.maxVulnerabilitiesPerFile
    };
  }
}

module.exports = VulnerabilityDetector;