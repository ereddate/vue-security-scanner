// src/core/vulnerability-detector.js
// 漏洞检测核心模块 - 增强版

const path = require('path');
const { ErrorHandler } = require('../utils/error-handler');
const { analyzeWithAdvancedRules, analyzeWithRulesLimited } = require('../rules/rule-engine');
const IgnoreManager = require('../utils/ignore-manager');
const ASTAnalyzer = require('../analysis/ast-analyzer');

class VulnerabilityDetector {
  constructor(config = {}) {
    this.config = config;
    this.ignoreManager = null;
    this.enableAdvancedAnalysis = config.enableAdvancedAnalysis !== false;
    this.maxVulnerabilitiesPerFile = config.maxVulnerabilitiesPerFile || 50;
    this.enableSemanticAnalysis = config.enableSemanticAnalysis !== false;
    this.astAnalyzer = new ASTAnalyzer({ enableSemanticAnalysis: this.enableSemanticAnalysis });
  }

  async detectVulnerabilities(filePath, content, projectPath = '.') {
    let vulnerabilities = [];
    
    try {
      if (!this.ignoreManager) {
        this.ignoreManager = new IgnoreManager(path.resolve(projectPath));
      }
      
      // 使用增强分析或标准分析（正则表达式）
      if (this.enableAdvancedAnalysis) {
        const checkVulns = analyzeWithAdvancedRules(filePath, content, this.maxVulnerabilitiesPerFile);
        vulnerabilities.push(...checkVulns);
      } else {
        const checkVulns = analyzeWithRulesLimited(filePath, content, this.maxVulnerabilitiesPerFile);
        vulnerabilities.push(...checkVulns);
      }
      
      // 使用AST语义分析（增强检测准确率）
      if (this.enableSemanticAnalysis) {
        const semanticVulns = this.astAnalyzer.analyze(filePath, content);
        
        // 合并正则和AST分析结果，去重
        const mergedVulns = this.mergeVulnerabilities(vulnerabilities, semanticVulns);
        vulnerabilities = mergedVulns;
      }
      
      // 过滤掉应该被忽略的漏洞
      vulnerabilities = vulnerabilities.filter(vuln => {
        return !this.ignoreManager.shouldIgnoreVulnerability(vuln);
      });
      
      // 对漏洞进行后处理和增强分析
      vulnerabilities = this.enhanceVulnerabilities(vulnerabilities, filePath, content);
      
    } catch (error) {
      const handledError = ErrorHandler.handleFileError(filePath, error);
      console.error(`Failed to detect vulnerabilities in ${filePath}:`, handledError.message);
    }
    
    return vulnerabilities;
  }

  mergeVulnerabilities(regexVulns, semanticVulns) {
    const merged = [...regexVulns];
    const seen = new Set();
    
    // 标记正则表达式检测到的漏洞
    regexVulns.forEach(vuln => {
      const key = `${vuln.file}:${vuln.line}:${vuln.ruleId}`;
      seen.add(key);
    });
    
    // 添加AST检测到的新漏洞（去重）
    semanticVulns.forEach(vuln => {
      const key = `${vuln.file}:${vuln.line}:${vuln.ruleId}`;
      if (!seen.has(key)) {
        merged.push(vuln);
        seen.add(key);
      }
    });
    
    return merged;
  }

  enhanceVulnerabilities(vulnerabilities, filePath, content) {
    return vulnerabilities.map(vuln => {
      // 添加额外的上下文信息
      let enhancedVuln = { ...vuln };
      
      // 添加文件类型信息
      enhancedVuln.fileType = path.extname(filePath).toLowerCase();
      
      // 添加框架特定信息
      if (enhancedVuln.fileType === '.vue') {
        enhancedVuln.framework = 'Vue.js';
        const vueAnalysis = this.analyzeVueSpecificIssues(enhancedVuln, content);
        enhancedVuln = { ...enhancedVuln, ...vueAnalysis };
      } else if (enhancedVuln.fileType === '.js' || enhancedVuln.fileType === '.jsx') {
        enhancedVuln.framework = 'JavaScript';
        const jsAnalysis = this.analyzeJSSpecificIssues(enhancedVuln, content);
        enhancedVuln = { ...enhancedVuln, ...jsAnalysis };
      }
      
      // 添加 CWE (Common Weakness Enumeration) 参考信息
      enhancedVuln.cwe = this.mapToCWE(enhancedVuln.ruleId);
      
      // 添加 OWASP Top 10 参考信息
      enhancedVuln.owaspCategory = this.mapToOWASP(enhancedVuln.ruleId);
      
      // 添加修复复杂度评估
      enhancedVuln.fixComplexity = this.assessFixComplexity(enhancedVuln);
      
      return enhancedVuln;
    });
  }

  analyzeVueSpecificIssues(vuln, content) {
    // Vue特定问题的分析
    const enhanced = { ...vuln };
    
    // 检查是否是Vue 2或Vue 3
    if (content.includes('createApp') || content.includes('defineComponent')) {
      enhanced.vueVersion = '3.x';
    } else if (content.includes('new Vue') || content.includes('Vue.component')) {
      enhanced.vueVersion = '2.x';
    }
    
    // 检查是否使用了Composition API
    if (content.includes('setup()') || content.includes('ref(') || content.includes('reactive(')) {
      enhanced.usesCompositionAPI = true;
    }
    
    // 检查是否使用了TypeScript
    if (content.includes('lang="ts"') || path.extname(vuln.file) === '.ts') {
      enhanced.usesTypeScript = true;
    }
    
    return enhanced;
  }

  analyzeJSSpecificIssues(vuln, content) {
    // JavaScript特定问题的分析
    const enhanced = { ...vuln };
    
    // 检查是否使用了现代JS语法
    if (content.includes('import ') || content.includes('export ')) {
      enhanced.usesESModules = true;
    }
    
    // 检查是否使用了异步操作
    if (content.includes('async ') || content.includes('await ') || content.includes('.then(')) {
      enhanced.usesAsyncOperations = true;
    }
    
    return enhanced;
  }

  mapToCWE(ruleId) {
    // 将规则ID映射到CWE编号
    const cweMapping = {
      'xss-v-html': 'CWE-79',
      'xss-dangerously-set-inner-html': 'CWE-79',
      'hardcoded-password': 'CWE-798',
      'hardcoded-secret': 'CWE-798',
      'sql-injection-sequelize': 'CWE-89',
      'command-injection': 'CWE-78',
      'path-traversal': 'CWE-22',
      'ssrf-vulnerable-request': 'CWE-918',
      'insecure-crypto-algorithm': 'CWE-327',
      'insecure-randomness': 'CWE-338',
      'insecure-storage': 'CWE-922',
      'insecure-communication': 'CWE-319',
      'information-disclosure': 'CWE-200',
      'insecure-direct-object-reference': 'CWE-639',
      'improper-authentication': 'CWE-287',
      'csrf-missing-token': 'CWE-352'
    };
    
    return cweMapping[ruleId] || 'CWE-16'; // 默认为配置问题
  }

  mapToOWASP(ruleId) {
    // 将规则ID映射到OWASP Top 10类别
    const owaspMapping = {
      'xss-v-html': 'A03:2021 – Injection',
      'xss-dangerously-set-inner-html': 'A03:2021 – Injection',
      'sql-injection-sequelize': 'A03:2021 – Injection',
      'command-injection': 'A03:2021 – Injection',
      'hardcoded-password': 'A02:2021 – Cryptographic Failures',
      'hardcoded-secret': 'A02:2021 – Cryptographic Failures',
      'insecure-crypto-algorithm': 'A02:2021 – Cryptographic Failures',
      'insecure-randomness': 'A02:2021 – Cryptographic Failures',
      'insecure-storage': 'A02:2021 – Cryptographic Failures',
      'insecure-communication': 'A02:2021 – Cryptographic Failures',
      'improper-authentication': 'A07:2021 – Identification and Authentication Failures',
      'csrf-missing-token': 'A01:2021 – Broken Access Control',
      'insecure-direct-object-reference': 'A01:2021 – Broken Access Control',
      'path-traversal': 'A01:2021 – Broken Access Control',
      'ssrf-vulnerable-request': 'A10:2021 – Server-Side Request Forgery',
      'information-disclosure': 'A04:2021 – Insecure Design',
      'insecure-dependency': 'A06:2021 – Vulnerable and Outdated Components'
    };
    
    return owaspMapping[ruleId] || 'A05:2021 – Security Misconfiguration';
  }

  assessFixComplexity(vuln) {
    // 评估修复复杂度
    const highComplexityRules = [
      'vue-composition-api',
      'vue-state-security',
      'vue-router-security',
      'ssrf-vulnerable-request',
      'command-injection'
    ];
    
    const mediumComplexityRules = [
      'xss-v-html',
      'sql-injection-sequelize',
      'insecure-crypto-algorithm',
      'insecure-storage'
    ];
    
    if (highComplexityRules.includes(vuln.ruleId)) {
      return 'High';
    } else if (mediumComplexityRules.includes(vuln.ruleId)) {
      return 'Medium';
    } else {
      return 'Low';
    }
  }

  // 添加单个检查方法 - 当前使用统一的漏洞检测函数
  async runSpecificCheck(checkName, filePath, content, projectPath = '.') {
    try {
      const allVulns = this.enableAdvancedAnalysis 
        ? analyzeWithAdvancedRules(filePath, content, this.maxVulnerabilitiesPerFile)
        : analyzeWithRulesLimited(filePath, content, this.maxVulnerabilitiesPerFile);
      
      // 初始化忽略管理器
      if (!this.ignoreManager) {
        this.ignoreManager = new IgnoreManager(path.resolve(projectPath));
      }
      
      // 过滤和增强漏洞
      const filteredVulns = allVulns.filter(vuln => {
        return !this.ignoreManager.shouldIgnoreVulnerability(vuln);
      });
      
      return this.enhanceVulnerabilities(filteredVulns, filePath, content);
    } catch (error) {
      const handledError = ErrorHandler.handleFileError(filePath, error);
      console.error(`Error running vulnerability check on ${filePath}:`, handledError.message);
      return [];
    }
  }

  updateConfig(newConfig) {
    this.config = { ...this.config, ...newConfig };
    
    if (newConfig.enableAdvancedAnalysis !== undefined) {
      this.enableAdvancedAnalysis = newConfig.enableAdvancedAnalysis;
    }
    
    if (newConfig.maxVulnerabilitiesPerFile !== undefined) {
      this.maxVulnerabilitiesPerFile = newConfig.maxVulnerabilitiesPerFile;
    }
    
    if (newConfig.enableSemanticAnalysis !== undefined) {
      this.enableSemanticAnalysis = newConfig.enableSemanticAnalysis;
      this.astAnalyzer = new ASTAnalyzer({ enableSemanticAnalysis: this.enableSemanticAnalysis });
    }
  }

  getDetectionStats() {
    return {
      enableAdvancedAnalysis: this.enableAdvancedAnalysis,
      enableSemanticAnalysis: this.enableSemanticAnalysis,
      maxVulnerabilitiesPerFile: this.maxVulnerabilitiesPerFile
    };
  }
}

module.exports = VulnerabilityDetector;