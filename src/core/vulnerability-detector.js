// src/core/vulnerability-detector.js
// 漏洞检测核心模块

const path = require('path');
const { ErrorHandler } = require('../utils/error-handler');
const { analyzeWithRulesLimited } = require('../rules/rule-engine');
const IgnoreManager = require('../utils/ignore-manager');

class VulnerabilityDetector {
  constructor(config = {}) {
    this.config = config;
    this.ignoreManager = null;
  }

  async detectVulnerabilities(filePath, content, projectPath = '.') {
    let vulnerabilities = [];
    
    try {
      if (!this.ignoreManager) {
        this.ignoreManager = new IgnoreManager(path.resolve(projectPath));
      }
      
      const checkVulns = analyzeWithRulesLimited(filePath, content, 50);
      vulnerabilities.push(...checkVulns);
      
      vulnerabilities = vulnerabilities.filter(vuln => {
        return !this.ignoreManager.shouldIgnoreVulnerability(vuln);
      });
      
    } catch (error) {
      const handledError = ErrorHandler.handleFileError(filePath, error);
      console.error(`Failed to detect vulnerabilities in ${filePath}:`, handledError.message);
    }
    
    return vulnerabilities;
  }

  // 添加单个检查方法 - 当前使用统一的漏洞检测函数
  async runSpecificCheck(checkName, filePath, content, projectPath = '.') {
    try {
      const allVulns = findAllVulnerabilities(filePath, content);
      
      // 初始化忽略管理器
      if (!this.ignoreManager) {
        this.ignoreManager = new IgnoreManager(path.resolve(projectPath));
      }
      
      return allVulns.filter(vuln => {
        return !this.ignoreManager.shouldIgnoreVulnerability(vuln);
      });
    } catch (error) {
      const handledError = ErrorHandler.handleFileError(filePath, error);
      console.error(`Error running vulnerability check on ${filePath}:`, handledError.message);
      return [];
    }
  }

  updateConfig(newConfig) {
    this.config = { ...this.config, ...newConfig };
  }
}

module.exports = VulnerabilityDetector;