// src/core/vulnerability-detector.js
// 漏洞检测核心模块 - 增强版

const path = require('path');
const { ErrorHandler } = require('../utils/error-handler');
const { analyzeWithAdvancedRules, analyzeWithRulesLimited } = require('../rules/rule-engine');
const IgnoreManager = require('../utils/ignore-manager');
const ASTAnalyzer = require('../analysis/ast-analyzer');
const IntelligentVulnerabilityAnalyzer = require('../ai/intelligent-vulnerability-analyzer');
const VulnerabilityDataManager = require('./vulnerability-data-manager');
const vulnerabilityDataConfig = require('../config/vulnerability-data');

class VulnerabilityDetector {
  constructor(config = {}) {
    this.config = config;
    this.ignoreManager = null;
    this.enableAdvancedAnalysis = config.enableAdvancedAnalysis !== false;
    this.maxVulnerabilitiesPerFile = config.maxVulnerabilitiesPerFile || 50;
    this.enableSemanticAnalysis = config.enableSemanticAnalysis !== false;
    this.astAnalyzer = new ASTAnalyzer({ enableSemanticAnalysis: this.enableSemanticAnalysis });
    this.ruleExtensionAPI = null; // 规则扩展API实例
    this.intelligentAnalyzer = new IntelligentVulnerabilityAnalyzer({
      ...config.ai,
      enableLLMIntegration: true
    }); // 智能分析器
    this.vulnerabilityDataManager = null; // 漏洞数据源管理器实例
    this.enableVulnerabilityDataAnalysis = config.enableVulnerabilityDataAnalysis !== false;
    
    // 初始化漏洞数据源管理器
    if (this.enableVulnerabilityDataAnalysis && vulnerabilityDataConfig.getConfig().enabled) {
      this.initializeVulnerabilityDataManager();
    }
  }
  
  initializeVulnerabilityDataManager() {
    try {
      this.vulnerabilityDataManager = new VulnerabilityDataManager({
        storagePath: vulnerabilityDataConfig.getStoragePath()
      });
      
      // 注册数据源
      const dataSources = vulnerabilityDataConfig.getConfig().dataSources;
      if (dataSources.nvd && dataSources.nvd.enabled) {
        const NVDataSource = require('./data-sources/nvd-data-source');
        this.vulnerabilityDataManager.registerDataSource('nvd', new NVDataSource(dataSources.nvd));
      }
      
      if (dataSources.github && dataSources.github.enabled) {
        const GitHubAdvisoryDataSource = require('./data-sources/github-advisory-data-source');
        this.vulnerabilityDataManager.registerDataSource('github', new GitHubAdvisoryDataSource(dataSources.github));
      }
      
      if (dataSources.vue && dataSources.vue.enabled) {
        const VueEcosystemDataSource = require('./data-sources/vue-ecosystem-data-source');
        this.vulnerabilityDataManager.registerDataSource('vue', new VueEcosystemDataSource(dataSources.vue));
      }
      
      console.log('Vulnerability data manager initialized successfully');
    } catch (error) {
      console.warn('Failed to initialize vulnerability data manager:', error.message);
    }
  }

  async detectVulnerabilities(filePath, content, projectPath = '.') {
    let vulnerabilities = [];
    
    try {
      // 初始化忽略管理器
      if (!this.ignoreManager) {
        this.ignoreManager = new IgnoreManager(path.resolve(projectPath));
      }
      
      // 使用增强分析或标准分析（正则表达式）
      if (this.enableAdvancedAnalysis) {
        const checkVulns = analyzeWithAdvancedRules(filePath, content, this.maxVulnerabilitiesPerFile);
        vulnerabilities.push(...checkVulns);
      } else {
        const checkVulns = analyzeWithRulesLimited(filePath, content, this.maxVulnerabilitiesPerFile);
        vulnerabilities.push(...checkVulns);
      }
      
      // 使用规则扩展API检测自定义规则
      if (this.ruleExtensionAPI) {
        const extendedVulns = await this.applyExtendedRules(filePath, content);
        vulnerabilities.push(...extendedVulns);
      }
      
      // 使用语义分析
      if (this.enableSemanticAnalysis) {
        const semanticVulns = this.astAnalyzer.analyze(filePath, content);
        vulnerabilities = this.mergeVulnerabilities(vulnerabilities, semanticVulns);
      }
      
      // 对漏洞进行后处理和增强分析
      vulnerabilities = this.enhanceVulnerabilities(vulnerabilities, filePath, content);
      
      // 应用智能分析
      vulnerabilities = this.applyIntelligentAnalysis(vulnerabilities, { filePath, content, projectPath });
      
    } catch (error) {
      const handledError = ErrorHandler.handleFileError(filePath, error);
      console.error(`Failed to detect vulnerabilities in ${filePath}:`, handledError.message);
    }
    
    return vulnerabilities;
  }
  
  /**
   * Apply intelligent analysis to vulnerabilities
   * @param {Array} vulnerabilities - Array of vulnerabilities
   * @param {Object} context - Context information
   * @returns {Array} - Analyzed vulnerabilities
   */
  applyIntelligentAnalysis(vulnerabilities, context) {
    if (!this.intelligentAnalyzer) {
      return vulnerabilities;
    }
    
    try {
      // 执行智能分析
      return this.intelligentAnalyzer.analyzeVulnerabilities(vulnerabilities, context);
    } catch (error) {
      console.warn('Intelligent analysis failed:', error.message);
      // 返回原始漏洞，不应用智能分析
      return vulnerabilities;
    }
  }
  
  /**
   * Apply extended/custom rules from the rule extension API
   * @param {string} filePath - The file path
   * @param {string} content - The file content
   * @returns {Array} - Array of vulnerabilities found by extended rules
   */
  async applyExtendedRules(filePath, content) {
    if (!this.ruleExtensionAPI) {
      return [];
    }
    
    const extendedVulnerabilities = [];
    const activeRules = this.ruleExtensionAPI.getActiveRules();
    
    for (const rule of activeRules) {
      // 检查文件类型是否匹配
      if (rule.fileTypes && !rule.fileTypes.includes(path.extname(filePath))) {
        continue;
      }
      
      try {
        // 使用正则表达式模式进行匹配
        if (rule.pattern) {
          const regex = new RegExp(rule.pattern, 'gi');
          let match;
          
          while ((match = regex.exec(content)) !== null) {
            const lineNum = this.getLineNumber(content, match.index);
            
            extendedVulnerabilities.push({
              file: filePath,
              line: lineNum,
              ruleId: rule.id,
              description: rule.description,
              severity: rule.severity,
              category: rule.category,
              matchedContent: match[0],
              type: rule.name
            });
          }
        }
        
        // 使用自定义验证函数进行匹配
        if (rule.validator && typeof rule.validator === 'function') {
          const validationResults = rule.validator(filePath, content, rule);
          if (validationResults && Array.isArray(validationResults)) {
            extendedVulnerabilities.push(...validationResults);
          } else if (validationResults && typeof validationResults === 'object') {
            extendedVulnerabilities.push(validationResults);
          }
        }
      } catch (error) {
        console.warn(`Error applying extended rule ${rule.id}:`, error.message);
      }
    }
    
    return extendedVulnerabilities;
  }
  
  /**
   * Get line number for a character index in content
   * @param {string} content - The file content
   * @param {number} index - Character index
   * @returns {number} - Line number
   */
  getLineNumber(content, index) {
    return content.substring(0, index).split('\n').length;
  }
  
  /**
   * Set the rule extension API instance
   * @param {RuleExtensionAPI} api - The rule extension API instance
   */
  setRuleExtensionAPI(api) {
    this.ruleExtensionAPI = api;
  }
  
  /**
   * Update configuration
   * @param {Object} newConfig - New configuration
   */
  updateConfig(newConfig) {
    this.config = { ...this.config, ...newConfig };
    if (newConfig.enableAdvancedAnalysis !== undefined) {
      this.enableAdvancedAnalysis = newConfig.enableAdvancedAnalysis;
    }
    if (newConfig.maxVulnerabilitiesPerFile) {
      this.maxVulnerabilitiesPerFile = newConfig.maxVulnerabilitiesPerFile;
    }
    if (newConfig.enableSemanticAnalysis !== undefined) {
      this.enableSemanticAnalysis = newConfig.enableSemanticAnalysis;
    }
  }

  mergeVulnerabilities(regexVulns, semanticVulns) {
    const merged = [...regexVulns];
    const seen = new Set();
    
    // 标记正则表达式检测到的漏洞
    regexVulns.forEach(vuln => {
      const key = `${vuln.file}:${vuln.line}:${vuln.ruleId}`;
      seen.add(key);
    });
    
    // 添加AST检测到的新漏洞（去重）
    semanticVulns.forEach(vuln => {
      const key = `${vuln.file}:${vuln.line}:${vuln.ruleId}`;
      if (!seen.has(key)) {
        merged.push(vuln);
        seen.add(key);
      }
    });
    
    return merged;
  }

  enhanceVulnerabilities(vulnerabilities, filePath, content) {
    return vulnerabilities.map(vuln => {
      // 添加额外的上下文信息
      let enhancedVuln = { ...vuln };
      
      // 添加文件类型信息
      enhancedVuln.fileType = path.extname(filePath).toLowerCase();
      
      // 添加框架特定信息
      if (enhancedVuln.fileType === '.vue' || enhancedVuln.fileType === '.nvue') {
        enhancedVuln.framework = 'Vue.js';
        const vueAnalysis = this.analyzeVueSpecificIssues(enhancedVuln, content);
        enhancedVuln = { ...enhancedVuln, ...vueAnalysis };
      } else if (enhancedVuln.fileType === '.js' || enhancedVuln.fileType === '.jsx') {
        enhancedVuln.framework = 'JavaScript';
        const jsAnalysis = this.analyzeJSSpecificIssues(enhancedVuln, content);
        enhancedVuln = { ...enhancedVuln, ...jsAnalysis };
      } else if (enhancedVuln.fileType === '.wxml' || enhancedVuln.fileType === '.wxss' || enhancedVuln.fileType === '.wxs') {
        enhancedVuln.framework = 'WeChat Mini Program';
        const miniAppAnalysis = this.analyzeMiniAppSpecificIssues(enhancedVuln, content);
        enhancedVuln = { ...enhancedVuln, ...miniAppAnalysis };
      } else if (enhancedVuln.fileType === '.json') {
        enhancedVuln.framework = this.detectFrameworkFromJSON(filePath, content);
      } else if (enhancedVuln.fileType === '.tsx' || enhancedVuln.fileType === '.jsx') {
        // 检测Taro框架
        if (filePath.includes('app.tsx') || filePath.includes('app.jsx') || content.includes('@tarojs')) {
          enhancedVuln.framework = 'Taro';
          const taroAnalysis = this.analyzeTaroSpecificIssues(enhancedVuln, content);
          enhancedVuln = { ...enhancedVuln, ...taroAnalysis };
        } else {
          enhancedVuln.framework = 'React';
        }
      } else if (enhancedVuln.fileType === '.html' || enhancedVuln.fileType === '.swan' || enhancedVuln.fileType === '.ttml' || enhancedVuln.fileType === '.qml') {
        enhancedVuln.framework = this.detectFrameworkFromMarkup(filePath, content);
      }
      
      // 添加 CWE (Common Weakness Enumeration) 参考信息
      enhancedVuln.cwe = this.mapToCWE(enhancedVuln.ruleId);
      
      // 添加 OWASP Top 10 参考信息
      enhancedVuln.owaspCategory = this.mapToOWASP(enhancedVuln.ruleId);
      
      // 添加修复复杂度评估
      enhancedVuln.fixComplexity = this.assessFixComplexity(enhancedVuln);
      
      return enhancedVuln;
    });
  }

  analyzeVueSpecificIssues(vuln, content) {
    // Vue特定问题的分析
    const enhanced = { ...vuln };
    
    // 检查是否是Vue 2或Vue 3
    if (content.includes('createApp') || content.includes('defineComponent')) {
      enhanced.vueVersion = '3.x';
    } else if (content.includes('new Vue') || content.includes('Vue.component')) {
      enhanced.vueVersion = '2.x';
    }
    
    // 检查是否使用了Composition API
    if (content.includes('setup()') || content.includes('ref(') || content.includes('reactive(')) {
      enhanced.usesCompositionAPI = true;
    }
    
    // 检查是否使用了TypeScript
    if (content.includes('lang="ts"') || path.extname(vuln.file) === '.ts') {
      enhanced.usesTypeScript = true;
    }
    
    return enhanced;
  }

  analyzeJSSpecificIssues(vuln, content) {
    // JavaScript特定问题的分析
    const enhanced = { ...vuln };
    
    // 检查是否使用了现代JS语法
    if (content.includes('import ') || content.includes('export ')) {
      enhanced.usesESModules = true;
    }
    
    // 检查是否使用了异步操作
    if (content.includes('async ') || content.includes('await ') || content.includes('.then(')) {
      enhanced.usesAsync = true;
    }
    
    return enhanced;
  }

  analyzeMiniAppSpecificIssues(vuln, content) {
    // 小程序特定问题的分析
    const enhanced = { ...vuln };
    
    // 检查是否使用了小程序API
    if (content.includes('wx.') || content.includes('uni.')) {
      enhanced.usesMiniAppAPI = true;
    }
    
    // 检查是否使用了不安全的模板语法
    if (content.includes('{{') && content.includes('}}')) {
      enhanced.usesTemplateInterpolation = true;
    }
    
    return enhanced;
  }

  analyzeTaroSpecificIssues(vuln, content) {
    // Taro特定问题的分析
    const enhanced = { ...vuln };
    
    // 检查是否使用了Taro API
    if (content.includes('Taro.') || content.includes('@tarojs/')) {
      enhanced.usesTaroAPI = true;
    }
    
    // 检查是否使用了Taro导航API
    if (content.includes('Taro.navigateTo') || content.includes('Taro.redirectTo') || content.includes('Taro.switchTab')) {
      enhanced.usesTaroNavigation = true;
    }
    
    // 检查是否使用了Taro网络请求API
    if (content.includes('Taro.request')) {
      enhanced.usesTaroNetwork = true;
    }
    
    return enhanced;
  }

  detectFrameworkFromJSON(filePath, content) {
    // 从JSON文件检测框架
    try {
      const jsonContent = JSON.parse(content);
      
      // 检测uni-app
      if (filePath.includes('pages.json') || filePath.includes('manifest.json')) {
        if (jsonContent.uniPlatform || jsonContent.appid) {
          return 'uni-app';
        }
      }
      
      // 检测微信小程序
      if (filePath.includes('app.json') || filePath.includes('project.config.json')) {
        if (jsonContent.pages || jsonContent.appid) {
          return 'WeChat Mini Program';
        }
      }
      
      // 检测Taro框架
      if (filePath.includes('app.config.ts') || filePath.includes('app.config.js') || filePath.includes('.config.ts') || filePath.includes('.config.js')) {
        if (jsonContent.pages || jsonContent.window || jsonContent.tabBar) {
          return 'Taro';
        }
      }
      
      // 检测package.json中的框架信息
      if (filePath.includes('package.json')) {
        if (jsonContent.dependencies && jsonContent.dependencies['@tarojs/taro']) {
          return 'Taro';
        }
      }
      
      // 检测其他小程序框架
      if (jsonContent.swanPages) return 'Baidu Smart Program';
      if (jsonContent.ttPages) return 'ByteDance Mini Program';
      if (jsonContent.qmlPages) return 'QQ Mini Program';
      
    } catch (error) {
      // JSON解析失败，返回默认值
    }
    
    return 'Unknown';
  }

  detectFrameworkFromMarkup(filePath, content) {
    // 从标记文件检测框架
    
    // 检测uni-app
    if (filePath.includes('.nvue') || content.includes('uni-app') || content.includes('@uni/')) {
      return 'uni-app';
    }
    
    // 检测微信小程序
    if (filePath.includes('.wxml') || content.includes('wx:') || content.includes('WeixinJSBridge')) {
      return 'WeChat Mini Program';
    }
    
    // 检测百度智能小程序
    if (filePath.includes('.swan') || content.includes('swan:')) {
      return 'Baidu Smart Program';
    }
    
    // 检测字节跳动小程序
    if (filePath.includes('.ttml') || content.includes('tt:')) {
      return 'ByteDance Mini Program';
    }
    
    // 检测QQ小程序
    if (filePath.includes('.qml') || content.includes('qq:')) {
      return 'QQ Mini Program';
    }
    
    // 检测普通HTML
    if (filePath.includes('.html')) {
      return 'HTML';
    }
    
    return 'Unknown';
  }

  mapToCWE(ruleId) {
    // 将规则ID映射到CWE编号
    const cweMapping = {
      'xss-v-html': 'CWE-79',
      'xss-dangerously-set-inner-html': 'CWE-79',
      'hardcoded-password': 'CWE-798',
      'hardcoded-secret': 'CWE-798',
      'sql-injection-sequelize': 'CWE-89',
      'command-injection': 'CWE-78',
      'path-traversal': 'CWE-22',
      'ssrf-vulnerable-request': 'CWE-918',
      'insecure-crypto-algorithm': 'CWE-327',
      'insecure-randomness': 'CWE-338',
      'insecure-storage': 'CWE-922',
      'insecure-communication': 'CWE-319',
      'information-disclosure': 'CWE-200',
      'insecure-direct-object-reference': 'CWE-639',
      'improper-authentication': 'CWE-287',
      'csrf-missing-token': 'CWE-352'
    };
    
    return cweMapping[ruleId] || 'CWE-16'; // 默认为配置问题
  }

  mapToOWASP(ruleId) {
    // 将规则ID映射到OWASP Top 10类别
    const owaspMapping = {
      'xss-v-html': 'A03:2021 – Injection',
      'xss-dangerously-set-inner-html': 'A03:2021 – Injection',
      'sql-injection-sequelize': 'A03:2021 – Injection',
      'command-injection': 'A03:2021 – Injection',
      'hardcoded-password': 'A02:2021 – Cryptographic Failures',
      'hardcoded-secret': 'A02:2021 – Cryptographic Failures',
      'insecure-crypto-algorithm': 'A02:2021 – Cryptographic Failures',
      'insecure-randomness': 'A02:2021 – Cryptographic Failures',
      'insecure-storage': 'A02:2021 – Cryptographic Failures',
      'insecure-communication': 'A02:2021 – Cryptographic Failures',
      'improper-authentication': 'A07:2021 – Identification and Authentication Failures',
      'csrf-missing-token': 'A01:2021 – Broken Access Control',
      'insecure-direct-object-reference': 'A01:2021 – Broken Access Control',
      'path-traversal': 'A01:2021 – Broken Access Control',
      'ssrf-vulnerable-request': 'A10:2021 – Server-Side Request Forgery',
      'information-disclosure': 'A04:2021 – Insecure Design',
      'insecure-dependency': 'A06:2021 – Vulnerable and Outdated Components'
    };
    
    return owaspMapping[ruleId] || 'A05:2021 – Security Misconfiguration';
  }

  assessFixComplexity(vuln) {
    // 评估修复复杂度
    const highComplexityRules = [
      'vue-composition-api',
      'vue-state-security',
      'vue-router-security',
      'ssrf-vulnerable-request',
      'command-injection'
    ];
    
    const mediumComplexityRules = [
      'xss-v-html',
      'sql-injection-sequelize',
      'insecure-crypto-algorithm',
      'insecure-storage'
    ];
    
    if (highComplexityRules.includes(vuln.ruleId)) {
      return 'High';
    } else if (mediumComplexityRules.includes(vuln.ruleId)) {
      return 'Medium';
    } else {
      return 'Low';
    }
  }

  // 添加单个检查方法 - 当前使用统一的漏洞检测函数
  async runSpecificCheck(checkName, filePath, content, projectPath = '.') {
    try {
      const allVulns = this.enableAdvancedAnalysis 
        ? analyzeWithAdvancedRules(filePath, content, this.maxVulnerabilitiesPerFile)
        : analyzeWithRulesLimited(filePath, content, this.maxVulnerabilitiesPerFile);
      
      // 初始化忽略管理器
      if (!this.ignoreManager) {
        this.ignoreManager = new IgnoreManager(path.resolve(projectPath));
      }
      
      // 过滤和增强漏洞
      const filteredVulns = allVulns.filter(vuln => {
        return !this.ignoreManager.shouldIgnoreVulnerability(vuln);
      });
      
      return this.enhanceVulnerabilities(filteredVulns, filePath, content);
    } catch (error) {
      const handledError = ErrorHandler.handleFileError(filePath, error);
      console.error(`Error running vulnerability check on ${filePath}:`, handledError.message);
      return [];
    }
  }

  updateConfig(newConfig) {
    this.config = { ...this.config, ...newConfig };
    
    if (newConfig.enableAdvancedAnalysis !== undefined) {
      this.enableAdvancedAnalysis = newConfig.enableAdvancedAnalysis;
    }
    
    if (newConfig.maxVulnerabilitiesPerFile !== undefined) {
      this.maxVulnerabilitiesPerFile = newConfig.maxVulnerabilitiesPerFile;
    }
    
    if (newConfig.enableSemanticAnalysis !== undefined) {
      this.enableSemanticAnalysis = newConfig.enableSemanticAnalysis;
      this.astAnalyzer = new ASTAnalyzer({ enableSemanticAnalysis: this.enableSemanticAnalysis });
    }
  }

  getDetectionStats() {
    return {
      enableAdvancedAnalysis: this.enableAdvancedAnalysis,
      enableSemanticAnalysis: this.enableSemanticAnalysis,
      maxVulnerabilitiesPerFile: this.maxVulnerabilitiesPerFile,
      enableVulnerabilityDataAnalysis: this.enableVulnerabilityDataAnalysis
    };
  }
  
  async analyzeDependencies(packageJsonContent) {
    if (!this.vulnerabilityDataManager) {
      console.warn('Vulnerability data manager is not available');
      return [];
    }
    
    try {
      const packageData = JSON.parse(packageJsonContent);
      const dependencies = {
        ...packageData.dependencies,
        ...packageData.devDependencies
      };

      const vulnerabilities = [];
      
      for (const [name, version] of Object.entries(dependencies)) {
        try {
          const depVulns = this.vulnerabilityDataManager.findVulnerabilitiesForDependency(name, version);
          if (depVulns.length > 0) {
            vulnerabilities.push({
              dependency: name,
              version,
              vulnerabilities: depVulns,
              severity: this.calculateOverallSeverity(depVulns),
              count: depVulns.length
            });
          }
        } catch (error) {
          console.warn(`Failed to analyze dependency ${name}:`, error.message);
        }
      }
      
      return vulnerabilities;
    } catch (error) {
      console.warn('Dependency analysis failed:', error.message);
      return [];
    }
  }
  
  calculateOverallSeverity(vulnerabilities) {
    if (!vulnerabilities || vulnerabilities.length === 0) {
      return 'Low';
    }
    
    const severityOrder = ['Low', 'Medium', 'High', 'Critical'];
    let maxSeverity = 'Low';
    
    for (const vuln of vulnerabilities) {
      const vulnSeverity = vuln.severity || 'Medium';
      if (severityOrder.indexOf(vulnSeverity) > severityOrder.indexOf(maxSeverity)) {
        maxSeverity = vulnSeverity;
      }
    }
    
    return maxSeverity;
  }
  
  async syncVulnerabilityData() {
    if (!this.vulnerabilityDataManager) {
      console.warn('Vulnerability data manager is not available');
      return false;
    }
    
    try {
      await this.vulnerabilityDataManager.syncAllDataSources();
      return true;
    } catch (error) {
      console.error('Failed to sync vulnerability data:', error.message);
      return false;
    }
  }
  
  getVulnerabilityDataStatistics() {
    if (!this.vulnerabilityDataManager) {
      return null;
    }
    
    return this.vulnerabilityDataManager.getStatistics();
  }
  
  async searchVulnerabilities(query) {
    if (!this.vulnerabilityDataManager) {
      console.warn('Vulnerability data manager is not available');
      return [];
    }
    
    try {
      return this.vulnerabilityDataManager.searchVulnerabilities(query);
    } catch (error) {
      console.warn('Failed to search vulnerabilities:', error.message);
      return [];
    }
  }
  
  async getVulnerabilityDetails(cveId) {
    if (!this.vulnerabilityDataManager) {
      console.warn('Vulnerability data manager is not available');
      return null;
    }
    
    try {
      return this.vulnerabilityDataManager.getVulnerabilityDetails(cveId);
    } catch (error) {
      console.warn(`Failed to get vulnerability details for ${cveId}:`, error.message);
      return null;
    }
  }
}

module.exports = VulnerabilityDetector;