// src/core/vulnerability-detector.js
// 漏洞检测核心模块

const path = require('path');
const { findAllVulnerabilities } = require('../checks/security-checks');
const { ErrorHandler } = require('../utils/error-handler');
const pluginManager = require('../plugin-system/plugin-manager');
const IgnoreManager = require('../utils/ignore-manager');

class VulnerabilityDetector {
  constructor(config = {}) {
    this.config = config;
    this.enabledChecks = this.initializeChecks();
    this.ignoreManager = null;
  }

  initializeChecks() {
    const checks = {};
    
    // 使用统一的漏洞检测函数
    checks.all = findAllVulnerabilities;
    
    return checks;
  }

  async detectVulnerabilities(filePath, content, projectPath = '.') {
    let vulnerabilities = [];
    
    try {
      // 初始化忽略管理器
      if (!this.ignoreManager) {
        this.ignoreManager = new IgnoreManager(path.resolve(projectPath));
      }
      
      // 首次运行时自动加载插件
      if (!this.pluginsLoaded) {
        await pluginManager.loadPluginsFromDirectory('./plugins');
        this.pluginsLoaded = true;
      }
      
      // 执行内置检查 - 使用统一的漏洞检测函数
      try {
        const checkVulns = findAllVulnerabilities(filePath, content);
        vulnerabilities.push(...checkVulns);
      } catch (error) {
        console.warn(`Error in vulnerability check for ${filePath}:`, error.message);
        // 继续执行其他检查，不要因为一个检查失败而停止整个扫描
      }
      
      // 执行插件检查
      const pluginVulns = await pluginManager.runPlugins(filePath, content);
      vulnerabilities.push(...pluginVulns);
      
      // 应用忽略规则过滤漏洞
      vulnerabilities = vulnerabilities.filter(vuln => {
        return !this.ignoreManager.shouldIgnoreVulnerability(vuln);
      });
      
    } catch (error) {
      const handledError = ErrorHandler.handleFileError(filePath, error);
      console.error(`Failed to detect vulnerabilities in ${filePath}:`, handledError.message);
    }
    
    return vulnerabilities;
  }

  // 添加单个检查方法 - 当前使用统一的漏洞检测函数
  async runSpecificCheck(checkName, filePath, content, projectPath = '.') {
    try {
      const allVulns = findAllVulnerabilities(filePath, content);
      
      // 初始化忽略管理器
      if (!this.ignoreManager) {
        this.ignoreManager = new IgnoreManager(path.resolve(projectPath));
      }
      
      // 应用忽略规则过滤漏洞
      return allVulns.filter(vuln => {
        return !this.ignoreManager.shouldIgnoreVulnerability(vuln);
      });
    } catch (error) {
      const handledError = ErrorHandler.handleFileError(filePath, error);
      console.error(`Error running vulnerability check on ${filePath}:`, handledError.message);
      return [];
    }
  }

  updateConfig(newConfig) {
    this.config = { ...this.config, ...newConfig };
    this.enabledChecks = this.initializeChecks();
  }
  
  // 插件管理方法
  registerPlugin(name, plugin) {
    pluginManager.registerPlugin(name, plugin);
  }
  
  enablePlugin(name) {
    pluginManager.enablePlugin(name);
  }
  
  disablePlugin(name) {
    pluginManager.disablePlugin(name);
  }
  
  getPluginsInfo() {
    return pluginManager.getPluginsInfo();
  }
}

module.exports = VulnerabilityDetector;